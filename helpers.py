from tkinter import *
from tkinter import ttk
from tktooltip import ToolTip
import os
from tkinter.filedialog import askopenfilename, askdirectory
import subprocess
import shutil
import datetime
import webbrowser as browser
import get_image_size

class FuncMenu():

    def __init__(self, master, variable=None, default=None, *values, command):
        self.menu = OptionMenu(master, variable, *values, command=self.callback)
        self.command = command
        self.name = variable
        self.text = variable.get()
    def callback(self, opt):
        print(opt)
        self.command(opt)
        self.name.set(self.text)

"""
Widget class that displays an output of anything, including terminal outputs or logs, while disallowing the user to edit the output.
"""
class Console():

    def __init__(self, master, startText:str='', columnn=0, roww=0, widthh=100, heightt=20):
        self.column = columnn
        self.row = roww
        self.width = widthh
        self.height = heightt
        self.lines = []
        self.miniTerminal = Text(master, width=self.width, height=self.height)
        ys = Scrollbar(master, orient='vertical', command=self.miniTerminal.yview)
        self.miniTerminal['yscrollcommand'] = ys.set
        self.miniTerminal.insert('1.0', startText)
        if startText.find("\n") != -1:
            self.lines = startText.split('\n')
        else:
            self.lines.append(startText)
        self.miniTerminal['state'] = 'disabled'
    
    # Sets the output of the console to something else.
    def setOutput(self, replace:str):
        self.miniTerminal['state'] = 'normal'
        self.miniTerminal.delete('1.0', 'end')
        self.miniTerminal.insert('1.0', replace)
        self.miniTerminal['state'] = 'disabled'
        if replace.find("\n") != -1:
            self.lines = replace.split('\n')
        else:
            self.lines.append(replace)
    
    # Appends a new line to the bottom of the console.
    def append(self, e:str):
        self.miniTerminal['state'] = 'normal'
        self.miniTerminal.insert('end', e)
        self.lines.append(e)
        self.miniTerminal['state'] = 'disabled'
    
    # Clears the output completely.
    def clear(self):
        self.lines = []
        self.miniTerminal['state'] = 'normal'
        self.miniTerminal.delete('1.0', 'end')
        self.miniTerminal['state'] = 'disabled'
    
    # Checks if the output is empty and returns true if it is.
    def isEmpty(self):
        if len(self.lines) == 0:
            return True
        return False
    
    # Helper function that formats outputted text generated by the subprocess library to be usable for the class.
    def subprocessHelper(self, query):
        tOutputTmp = query.split('\n')
        tOutputTmp.pop(0)
        tOutput = ''
        count = -1
        llChk = len(tOutputTmp) - 1
        if len(tOutputTmp) == 1:
            tOutput += tOutputTmp[0]
        else:
            for l in tOutputTmp:
                count += 1
                if count == llChk:
                    tOutput += tOutputTmp[count]
                else:
                    tOutput += tOutputTmp[count] + '\n'
        return tOutput
    
    # Show the console
    def show(self):
        self.miniTerminal.grid(column=self.column, row=self.row, sticky=(N, S, E, W), columnspan=69)
    
    # Hide the console
    def hide(self):
        self.miniTerminal.grid_remove()

class BoolEntry():

    def __init__(self, master, textvariable, placeholder="placeholder", bg="white", fg="black", width=20):
        self.placeholder = placeholder
        self.entry = Entry(master, state="disabled", textvariable=textvariable, bg=bg, fg=fg, width=width)
    
    def grid(self, column=0, row=0, padx=0, pady=0, sticky="nsew"):
        self.entry.grid(column=column, row=row, padx=padx, pady=pady, sticky=sticky)
    
    def grid_remove(self):
        self.entry.grid_remove()
    
    def unlock(self):
        self.entry["state"] = 'normal'
        self.entry.delete('0', 'end')
    
    def lock(self):
        self.entry.delete('0', 'end')
        self.entry.insert('0', self.placeholder)
        self.entry["state"] = 'disabled'

class BoolSpinbox():

    def __init__(self, master, range=[0,1], increment=1, bg="white", bBG="bisque", fg="black"):
        self.entry = Spinbox(master, state="disabled", from_=range[0], to=range[1], bg=bg, buttonbackground=bBG, fg=fg, increment=increment, width=3)
    
    def grid(self, column=0, row=0, padx=0, pady=0, sticky="nsew"):
        self.entry.grid(column=column, row=row, padx=padx, pady=pady, sticky=sticky)
    
    def unlock(self):
        self.entry["state"] = 'normal'
    
    def lock(self):
        self.entry["state"] = 'disabled'
    
    def get(self):
        return self.entry.get()
    def changeTheme(self, newBG, newBbg, newFG):
        self.entry.config(bg=newBG)
        self.entry.config(buttonbackground=newBbg)
        self.entry.config(fg=newFG)

class QCHandler:

    def __init__(self, qc):
        f = open(qc, 'r')
        self.qcf = f.readlines()
        f.close()
        self.qcLoc = os.path.dirname(qc)
        self.cbarFrmt = False
    
    def relPathCheck(self):
        checks = 0
        count = -1
        cd = ""
        cdTex = ""
        newCD = ""
        cdLoc = 0
        newCDtex = ""
        cdTexLoc = 0
        self.newQC = self.qcf
        self.newQCPath = ""
        while checks < 2:
            count += 1
            try:
                qcL = self.qcf[count]
                if qcL.startswith("$cdtex"):
                    cdTexLoc = count
                    # Getting the string inside the $cdtex command, y'know, the thing inside the quotes? Yeah, that thing.
                    start = 0
                    end = 0
                    if qcL.find('\"') != -1:
                        start = qcL.find('\"')
                    else:
                        start = qcL.find("\'")
                    
                    if qcL.find('\"', start+1) != -1:
                        end = qcL.find('\"', start+1)
                    else:
                        end = qcL.find("\'", start+1)
                    cdTex = qcL[start+1:end]
                    print(f"cdtex directory: {cdTex}")
                    checks += 1
                elif qcL.startswith("$cd"):
                    cdLoc = count
                    # Getting the string inside the $cdtex command, y'know, the thing inside the quotes? Yeah, that thing.
                    start = 0
                    end = 0
                    if qcL.find('\"') != -1:
                        start = qcL.find('\"')
                    else:
                        start = qcL.find("\'")
                    
                    if qcL.find('\"', start+1) != -1:
                        end = qcL.find('\"', start+1)
                    else:
                        end = qcL.find("\'", start+1)
                    cd = qcL[start+1:end]
                    print(f"cdtex directory: {cdTex}")
                    checks += 1
            except:
                print("Something went wrong during cd checks! The model may not compile properly!")
                break
        if cd or cdTex != "":
            self.cbarFrmt = True
            print(cd)
            print(cdTex)
            if cd != "":
                newCD = self.qcf[cdLoc]
                if cd == "." or cd == "./":
                    newCD = newCD.replace(cd, f'{self.qcLoc}')
                elif cd.startswith("./"):
                    newCD = newCD.replace(cd, f'{self.qcLoc}/{cd[2:]}')
                else:
                    newCD = newCD.replace(cd, f'{self.qcLoc}/{cd}')
                self.newQC[cdLoc] = newCD
                print(newCD)
            if cdTex != "":
                newCDtex = self.qcf[cdTexLoc]
                if cdTex == "." or cdTex == "./":
                    newCDtex = newCDtex.replace(cdTex, f'{self.qcLoc}')
                elif cdTex.startswith("./"):
                    newCDtex = newCDtex.replace(cdTex, f'{self.qcLoc}/{cdTex[2:]}')
                else:
                    newCDtex = newCDtex.replace(cdTex, f'{self.qcLoc}/{cdTex}')
                self.newQC[cdTexLoc] = newCDtex
            elif cdTex == 2:
                newCDtex = self.qcf[cdTexLoc]
                newCDtex = newCDtex.replace('\".\"', f'\"{self.qcLoc}\"')
                self.newQC[cdTexLoc] = newCDtex
            self.newQCPath = os.path.join(self.qcLoc, "temp.qc")
            f = open(self.newQCPath, "w")
            f.write("".join(self.newQC))
            f.close()
    def getMDLname(self):
        checks = 0
        count = -1
        capture = False
        mdlName = ""
        while checks < 1:
            count += 1
            qcL = self.qcf[count]
            if qcL.startswith("$modelname"):
                for c in qcL:
                    if capture:
                        mdlName += c
                    if c == '\"' and not capture:
                        capture = True
                    elif c == '\"' and capture:
                        capture = False
                        break
                break
        return mdlName[:-1]
    
    def check1024px(self):
        checks = 0
        count = -1
        cdTex = ""
        newCDtex = ""
        self.newQC = self.qcf
        self.newQCPath = ""
        self.found1024 = False
        while checks < 1:
            count += 1
            qcL = self.qcf[count]
            if qcL.startswith("$cdtex"):
                # Getting the string inside the $cdtex command, y'know, the thing inside the quotes? Yeah, that thing.
                start = 0
                end = 0
                if qcL.find('\"') != -1:
                    start = qcL.find('\"')
                else:
                    start = qcL.find("\'")
                
                if qcL.find('\"', start+1) != -1:
                    end = qcL.find('\"', start+1)
                else:
                    end = qcL.find("\'", start+1)
                cdTex = qcL[start+1:end]
                print(f"cdtex directory: {cdTex}")
                checks += 1
        if cdTex != "":
            # if cdTex == 1:
            count = -1
            if cdTex == "." or cdTex == "./":
                texPath = self.qcLoc
            elif cdTex.startswith("./"):
                texPath = os.path.join(self.qcLoc, cdTex[2:])
            else:
                texPath = os.path.join(self.qcLoc, cdTex)
            textures = os.listdir(texPath)
            while count < len(textures)-1:
                count += 1
                tex = textures[count]
                fTex = os.path.join(self.qcLoc,tex)
                if os.path.isfile(fTex) and tex.endswith(".bmp"):
                    try:
                        width, height = get_image_size.get_image_size(fTex)
                    except get_image_size.UnknownImageFormat:
                        width, height = -1, -1
                    if width > 512 or height > 512:
                        self.found1024 = True
        return self.found1024
    
    def checkCHROME(self):
        checks = 0
        count = -1
        cdTex = ""
        newCDtex = ""
        texmodes = []
        self.newQC = self.qcf
        self.newQCPath = ""
        self.fndUnlChr = False
        while count < len(self.qcf)-1:
            count += 1
            qcL = self.qcf[count]
            if qcL.startswith("$cdtex"):
                # Getting the string inside the $cdtex command, y'know, the thing inside the quotes? Yeah, that thing.
                start = 0
                end = 0
                if qcL.find('\"') != -1:
                    start = qcL.find('\"')
                else:
                    start = qcL.find("\'")
                
                if qcL.find('\"', start+1) != -1:
                    end = qcL.find('\"', start+1)
                else:
                    end = qcL.find("\'", start+1)
                cdTex = qcL[start+1:end]
                print(f"cdtex directory: {cdTex}")
                checks += 1
        if cdTex != "":
            # if cdTex == 1:
            count = -1
            if cdTex == "." or cdTex == "./":
                texPath = self.qcLoc
            elif cdTex.startswith("./"):
                texPath = os.path.join(self.qcLoc, cdTex[2:])
            else:
                texPath = os.path.join(self.qcLoc, cdTex)
            textures = os.listdir(texPath)
            while count < len(textures)-1:
                count += 1
                tex = textures[count]
                fTex = os.path.join(self.qcLoc,tex)
                texL = tex.lower()
                print(tex)
                if texL.find("chrome") != -1 and os.path.isfile(fTex) and tex.endswith('.bmp'):
                    try:
                        width, height = get_image_size.get_image_size(fTex)
                    except get_image_size.UnknownImageFormat:
                        width, height = -1, -1
                    if not width == 64 or not height == 64:
                        self.fndUnlChr = True
        return self.fndUnlChr
    def checkTRM(self, renderM:int):
        count = -1
        rm = renderM
        newCDtex = ""
        texmodes = []
        self.newQC = self.qcf
        self.newQCPath = ""
        self.fndTRM = False
        while count < len(self.qcf)-1:
            count += 1
            qcL = self.qcf[count]
            noNL = qcL.replace("\n", "")
            if qcL.startswith("$texrendermode"):
                if rm == 0 and noNL.endswith("fullbright") or rm == 0 and noNL.endswith('fullbright\"') or rm == 0 and noNL.endswith('fullbright\''):
                    self.fndTRM = True
                    print("FULLBRIGHT FLAG")
                elif rm == 1 and noNL.endswith("flatshade") or rm == 1 and noNL.endswith('flatshade\"') or rm == 0 and noNL.endswith('fullbright\''):
                    self.fndTRM = True
                    print("FLATSHADE FLAG")
                elif rm == 2 and noNL.endswith("chrome") or rm == 2 and noNL.endswith('chrome\"') or rm == 2 and noNL.endswith('chrome\''):
                    self.fndTRM = True
                    print("CHROME FLAG")
        return self.fndTRM

class HyperlinkImg():

    def __init__(self, master, image:PhotoImage, lID:int=0):
        self.link = Label(master, image=image, cursor="hand2")
        self.link.bind("<Button-1>", lambda e: self.openLink(lID))
    
    def grid(self, column=0, row=0, padx=0, pady=0, sticky=""):
        self.link.grid(column=column, row=row, padx=padx, pady=pady, sticky=sticky)
    
    def openLink(self, id):
        if id == 0:
            browser.open_new("https://github.com/PostScriptReal/Snark_Compiler")
        elif id == 1:
            browser.open_new("https://gamebanana.com/tools/19255")

class Game():

    def __init__(self, name, isCustom):
        self.name = name
        self.isCustom = isCustom

class GamesHandler():

    def __init__(self, gList):
        count = -1
        self.games = []
        self.gNames = []
        while count < len(gList)-1:
            count += 1
            g = gList[count]
            if g.endswith("~"):
                a = Game(g[:-1], True)
                self.games.append(a)
                self.gNames.append(g[:-1])
            else:
                a = Game(g, False)
                self.games.append(a)
                self.gNames.append(g)
    
    def checkCustom(self, name):
        count = -1
        while count < len(self.games)-1:
            count += 1
            g = self.games[count]
            if g.name == name and g.isCustom:
                return True
        return False

class BatchMDL():

    def __init__(self, name:str, qcLoc:str, output:str):
        self.name = name
        self.qcLoc, self.mdlLoc = qcLoc, qcLoc
        self.skip = False
        self.output = output

class AlphaPrettify():

    def __init__(self, cmdOut:str, texSubFolder:bool, mdlDir:str):
        self.cmdOut = cmdOut.split('\n')
        self.texSF = texSubFolder
        self.mDir = mdlDir
        self.qcLoc = os.path.join(self.mDir, self.cmdOut[6].replace("QC script: MDL6job/", ""))
        with open(self.qcLoc, 'r') as qc:
            self.qcDat = qc.readlines()
        
        self.qcDat.insert(6, "\nOutput modified by Snark, the alternative to Crowbar for GoldSRC!\n")
        self.qcDat.insert(7, "Github: https://github.com/PostScriptReal/Snark_Compiler Gamebanana: https://gamebanana.com/tools/19255\n")
        self.qcDat.insert(8, "\n")
        
        texFolder = os.path.join(self.mDir, 'textures')
        if self.texSF:
            try:
                os.mkdir(texFolder)
            except:
                pass
            for f in os.listdir(self.mDir):
                if f.endswith('.bmp'):
                    shutil.copy(os.path.join(self.mDir, f), texFolder)
                    os.remove(os.path.join(self.mDir, f))
            cdLine = self.qcDat.index('$cd ".\\"\n')
            cdtexLine = self.qcDat.index('$cdtexture \".\\"\n')
            self.qcDat[cdLine] = '$cd \"./\"\n'
            self.qcDat[cdtexLine] = '$cdtexture \"./textures/\"\n'
        else:
            cdLine = self.qcDat.index('$cd ".\\"\n')
            cdtexLine = self.qcDat.index('$cdtexture \".\\"\n')
            self.qcDat[cdLine] = '$cd \"./\"\n'
            self.qcDat[cdtexLine] = '$cdtexture \"./\"\n'
        
        try:
            animsFolder = os.path.join(self.mDir, 'anims')
        except:
            pass
        try:
            os.mkdir(animsFolder)
        except:
            pass
        count = -1
        for l in self.cmdOut:
            if l.startswith("Sequence:"):
                animF = l.replace("Sequence: MDL6job/", "")
                shutil.copy(os.path.join(self.mDir, animF), animsFolder)
                os.remove(os.path.join(self.mDir, animF))
                animName = f"\"{animF.replace('.smd', '')}\""
                for s in self.qcDat:
                    count += 1
                    if s.startswith('$sequence'):
                        if s.find(animName) != -1:
                            substringStart = s.find(animName)+len(animName)+1
                            substring = s[substringStart:]
                            newSS = substring.replace(animName, f"\"anims/{animName.replace('\"', "", 1)}")
                            self.qcDat[count] = s.replace(substring, newSS)
                            break
                count = -1
        self.newQC = open(self.qcLoc, 'w')
        self.newQC.write(''.join(self.qcDat))
        self.newQC.close()